{"version":3,"file":"static/webpack/static/development/pages/index.js.d0338f871169cc959dcb.hot-update.js","sources":["webpack:///./lib/web3-contracts.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback, useMemo } from 'react'\nimport { Contract as EthersContract, utils as EthersUtils } from 'ethers'\nimport environment from 'lib/environment'\nimport { getKnownContract, getKnownAbi } from './known-contracts'\nimport { useWalletAugmented } from './wallet'\nimport { bigNum } from './utils'\nimport delay from 'delay'\n\n// See https://fundraising.aragon.black/components/bonding-curve#pricing-algorithm\nconst MAINNET_CONNECTOR_WEIGHT = 250000\nconst RINKEBY_CONNECTOR_WEIGHT = 33333\nconst RETRY_EVERY = 1000\n\nconst BATCH_SIZE = 10\n\nconst calculateBatchId = blockNumber =>\n  Math.floor(blockNumber / BATCH_SIZE) * BATCH_SIZE\n\nconst connectorWeights = new Map([\n  ['MAINNET_CONNECTOR_WEIGHT', MAINNET_CONNECTOR_WEIGHT],\n  ['RINKEBY_CONNECTOR_WEIGHT', RINKEBY_CONNECTOR_WEIGHT],\n])\nconst contractsCache = new Map()\nconst tokenDecimals = new Map([\n  ['COLLATERAL', 18],\n  ['BONDED', 18],\n])\n\nfunction getConnectorWeight() {\n  // FIXME: return a constant for now\n  return 400000\n\n  // const chainId = environment('CHAIN_ID')\n  // return connectorWeights.get(\n  //   chainId === '1' ? 'MAINNET_CONNECTOR_WEIGHT' : 'RINKEBY_CONNECTOR_WEIGHT'\n  // )\n}\n\nexport function useContract(address, abi, signer = true) {\n  const { ethersProvider } = useWalletAugmented()\n\n  if (!address || !ethersProvider) {\n    return null\n  }\n  if (contractsCache.has(address)) {\n    return contractsCache.get(address)\n  }\n\n  const contract = new EthersContract(\n    address,\n    abi,\n    signer ? ethersProvider.getSigner() : ethersProvider\n  )\n\n  contractsCache.set(address, contract)\n\n  return contract\n}\n\nexport function useKnownContract(name, signer = true) {\n  const [address, abi] = getKnownContract(name)\n  return useContract(address, abi, signer)\n}\n\nexport function useTokenDecimals(symbol) {\n  return tokenDecimals.get(symbol)\n}\n\nexport function useTokenBalance(symbol, address = '') {\n  const { account } = useWalletAugmented()\n  const [balance, setBalance] = useState(bigNum(-1))\n  const tokenContract = useKnownContract(`${symbol}`)\n\n  const cancelBalanceUpdate = useRef(null)\n\n  const updateBalance = useCallback(() => {\n    let cancelled = false\n\n    if (cancelBalanceUpdate.current) {\n      cancelBalanceUpdate.current()\n      cancelBalanceUpdate.current = null\n    }\n\n    if ((!account && !address) || !tokenContract) {\n      setBalance(bigNum(-1))\n      return\n    }\n\n    cancelBalanceUpdate.current = () => {\n      cancelled = true\n    }\n    const requestedAddress = address || account\n    setBalance(bigNum(100));\n    return;\n\n    tokenContract.balanceOf(requestedAddress).then(balance => {\n      if (!cancelled) {\n        setBalance(balance)\n      }\n    })\n  }, [account, address, tokenContract])\n\n  useEffect(() => {\n    // Always update the balance if updateBalance() has changed\n    updateBalance()\n\n    if ((!account && !address) || !tokenContract) {\n      return\n    }\n\n    const onTransfer = (from, to, value) => {\n      if (\n        from === account ||\n        to === account ||\n        from === address ||\n        to === address\n      ) {\n        updateBalance()\n      }\n    }\n    tokenContract.on('Transfer', onTransfer)\n\n    return () => {\n      tokenContract.removeListener('Transfer', onTransfer)\n    }\n  }, [account, address, tokenContract, updateBalance])\n\n  return balance\n}\n\nexport function useBondingCurvePrice(amount, forwards = true) {\n  const [loading, setLoading] = useState(false)\n  const [price, setPrice] = useState(bigNum(-1))\n  const anjContract = useKnownContract('BONDED')\n  const bancorContract = useKnownContract('BANCOR_FORMULA')\n\n  const [treasuryAddress] = getKnownContract('BONDING_CURVE_TREASURY')\n  const antTreasuryBalance = useTokenBalance('COLLATERAL', treasuryAddress)\n  const connectorWeight = getConnectorWeight()\n  useEffect(() => {\n    let cancelled = false\n    let retryTimer\n\n    if (!anjContract || antTreasuryBalance.eq(-1) || !bancorContract) {\n      return\n    }\n\n    const getSalePrice = async () => {\n      try {\n        setLoading(true)\n        const anjTotalSupply = await anjContract.totalSupply()\n        const salePrice = await (forwards\n          ? bancorContract.calculatePurchaseReturn(\n              anjTotalSupply,\n              antTreasuryBalance,\n              connectorWeight,\n              amount\n            )\n          : bancorContract.calculateSaleReturn(\n              anjTotalSupply,\n              antTreasuryBalance,\n              connectorWeight,\n              amount\n            ))\n        if (!cancelled) {\n          setLoading(false)\n          setPrice(salePrice)\n        }\n      } catch (err) {\n        if (!cancelled) {\n          retryTimer = setTimeout(getSalePrice, RETRY_EVERY)\n        }\n      }\n    }\n\n    getSalePrice()\n\n    return () => {\n      cancelled = true\n      clearTimeout(retryTimer)\n    }\n  }, [\n    amount,\n    anjContract,\n    antTreasuryBalance,\n    bancorContract,\n    connectorWeight,\n    forwards,\n  ])\n\n  return useMemo(() => ({ loading, price }), [loading, price])\n}\n\nexport function useAllowance() {\n  const { account } = useWalletAugmented()\n  const antContract = useKnownContract('COLLATERAL')\n  const [marketMakerAddress] = getKnownContract('MARKET_MAKER')\n\n  return useCallback(async () => {\n    try {\n      if (!antContract) {\n        throw new Error('COLLATERAL contract not loaded')\n      }\n\n      return await antContract.allowance(account, marketMakerAddress)\n    } catch (err) {\n      throw new Error(err.message)\n    }\n  }, [account, antContract, marketMakerAddress])\n}\n\nexport function useApprove() {\n  const antContract = useKnownContract('COLLATERAL')\n  const [marketMakerAddress] = getKnownContract('MARKET_MAKER')\n\n  return useCallback(\n    async amount => {\n      try {\n        if (!antContract) {\n          throw new Error('COLLATERAL contract not loaded')\n        }\n\n        return await antContract.approve(marketMakerAddress, amount)\n      } catch (err) {\n        throw new Error(err.message)\n      }\n    },\n    [antContract, marketMakerAddress]\n  )\n}\n\n// Convert COLLATERAL to BONDED action\nexport function useOpenOrder() {\n  const fundraisingContract = useKnownContract('FUNDRAISING')\n  const [antAddress] = getKnownContract('COLLATERAL')\n\n  return useCallback(\n    async (amount, toBonded = true) => {\n      try {\n        if (!fundraisingContract) {\n          throw new Error('Fundraising contract not loaded')\n        }\n\n        return await (toBonded\n          ? fundraisingContract.openBuyOrder(antAddress, amount, {\n              gasLimit: 650000,\n              value: 0,\n            })\n          : fundraisingContract.openSellOrder(antAddress, amount, {\n              gasLimit: 850000,\n            }))\n      } catch (err) {\n        throw new Error(err.message)\n      }\n    },\n    [antAddress, fundraisingContract]\n  )\n}\n\nexport function useClaimOrder() {\n  const { account, ethersProvider } = useWalletAugmented()\n  const fundraisingContract = useKnownContract('FUNDRAISING')\n  const [antAddress] = getKnownContract('COLLATERAL')\n\n  return useCallback(\n    async (openOrderTransactionHash, toBonded = true) => {\n      try {\n        if (!fundraisingContract) {\n          throw new Error('Fundraising contract error')\n        }\n\n        const { blockNumber } = await ethersProvider.getTransaction(\n          openOrderTransactionHash\n        )\n\n        const batchId = calculateBatchId(blockNumber)\n        // We claim the buy order, with the blockNumber of the emitted open order\n        return await (toBonded\n          ? fundraisingContract.claimBuyOrder(account, batchId, antAddress, {\n              gasLimit: 500000,\n            })\n          : fundraisingContract.claimSellOrder(account, batchId, antAddress, {\n              gasLimit: 500000,\n            }))\n      } catch (err) {\n        throw new Error(err)\n      }\n    },\n    [account, antAddress, ethersProvider, fundraisingContract]\n  )\n}\n\nexport function useWaitForTx() {\n  const { ethersProvider } = useWalletAugmented()\n\n  return useCallback(\n    async hash => {\n      try {\n        const tx = await ethersProvider.getTransaction(\n          hash\n        )\n        await tx.wait();\n      } catch (err) {\n        throw new Error(err)\n      }\n    },\n    [ethersProvider]\n  )\n}\n\nexport function useWaitForBatchToFinish() {\n  const { ethersProvider } = useWalletAugmented()\n  const fundraisingContract = useKnownContract('FUNDRAISING')\n  const marketMakerContract = useKnownContract('MARKET_MAKER')\n\n  return useCallback(\n    async openOrderTransactionHash => {\n      try {\n        if (!fundraisingContract) {\n          throw new Error('Fundraising contract error')\n        }\n        // Wait for transaction be deep enough as the batch size\n        let finished = false\n        do {\n          const { blockNumber } = await ethersProvider.getTransaction(\n            openOrderTransactionHash\n          )\n          const batchId = calculateBatchId(blockNumber)\n          const currentBatchId = await marketMakerContract.getCurrentBatchId()\n          finished = batchId < currentBatchId.toNumber()\n          if (!finished) {\n            await delay(15 * 1000) // 15 secs. TODO: Make this configurable\n          }\n        } while (!finished)\n      } catch (err) {\n        throw new Error(err)\n      }\n    },\n    [ethersProvider, fundraisingContract, marketMakerContract]\n  )\n}\n\nexport function useClaimOrderReceiptAmount() {\n  const { ethersProvider, account } = useWalletAugmented()\n\n  return useCallback(\n    async hash => {\n      const abi = getKnownAbi('COLLATERAL')\n      const [antAddress] = getKnownContract('COLLATERAL')\n      const [anjAddress] = getKnownContract('BONDED')\n      const abiInterface = new EthersUtils.Interface(abi)\n\n      try {\n        const transactionReceipt = await ethersProvider.getTransactionReceipt(\n          hash\n        )\n\n        const [parsedTransferLog] = transactionReceipt.logs\n          .filter(\n            log => log.address === antAddress || log.address === anjAddress\n          )\n          .map(log => abiInterface.parseLog(log))\n          .filter(log => log.args[1] === account)\n\n        const amount = parsedTransferLog.args.value\n\n        return amount ? amount : null\n      } catch (err) {\n        throw new Error(err)\n      }\n    },\n    [ethersProvider, account]\n  )\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAFA;AAAA;AACA;AADA;AAGA;AAHA;AAAA;AACA;AADA;AAIA;AACA;AAYA;AACA;AACA;AACA;AACA;AArBA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAqBA;AACA;AACA;AACA;AAzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA2BA;AAEA;AACA;AACA;AACA;AACA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AAQA;AACA;AAFA;AAKA;AADA;AACA;AAZA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAMA;AAIA;AACA;AAXA;AAAA;AAcA;AADA;AAIA;AADA;AACA;AAjBA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAEA;AAFA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AADA;AAKA;AACA;AACA;AAPA;AAAA;AAAA;AACA;AADA;AAAA;AAQA;AAGA;AAXA;AAAA;AACA;AADA;AAYA;AACA;AACA;AAdA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAIA;AAJA;AAAA;AAAA;AACA;AADA;AAOA;AAPA;AAaA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAlBA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;;;;A","sourceRoot":""}